@page "/indoor"

@using Microsoft.JSInterop
@inject IJSRuntime JsRuntime;

<div class="map">
    <!-- map is rendered row by row, top to bottom -->
    @for (int y = 0; y < map.Height; y++)
    {
        <div id="row_@y" class="row">
        @for (int x = 0; x < map.Width; x++)
        {
            string imgFileName = map.Tiles[x,y].ImageName + ".png";
            string tiletype = map.Tiles[x,y].TileType.ToString();
            string fovClass = map.IsVisibleMap[x,y] ? "" : "outoffov";
            string tileClass = $"tile {(fovClass)}";

            <div id="@x,@y" class="cell">
                <div class="tile" style="background-image: url('img/uf_terrain/floor_extra_11.png');" alt="@x,@y (dark background)"> </div>
                @if (map.IsMappedMap[x,y]){
                    <div class="@tileClass" style="background-image: url('img/uf_terrain/@imgFileName')" alt="@x,@y (@tiletype)"> </div>

                    @foreach (var decoration in map.AllDecorations(x,y))
                    {
                        if(decoration.GameObject.InvisibleOutsideFov && !map.IsVisibleMap[x,y]){
                            continue;
                        }

                        bool renderDiv = false;
                        string cssclass = "decoration";
                        string animationClass = "";
                        if(decoration.AnimationClass != null && decoration.AnimationClass != ""){
                            animationClass = @decoration.AnimationClass;
                            renderDiv = true;
                        }

                        var layerClass = "decbehind";
                        if(decoration.InFront){
                            layerClass = "decinfront";
                        }

                        cssclass = $"{cssclass} {(animationClass)} {(layerClass)} {(fovClass)}";

                        string style = "";
                        if(decoration.ImageName != null && decoration.ImageName != ""){
                            string decImgFileName = decoration.ImageName + ".png";
                            string offset = "";
                            if (decoration.Offset != 0)
                            {
                                offset = $" top: {decoration.Offset}px;";
                            }
                            if (decoration.HOffset != 0)
                            {
                                offset += $"left: {decoration.HOffset}px;";
                            }                        

                            renderDiv = true;
                            style = $"background-image: url('img/uf_terrain/{decImgFileName}');{offset}";
                        }

                        if(renderDiv)
                        {
                            <div class="@cssclass" style="@style" alt="@x,@y (Blocking=@decoration.GameObject.Blocking)"> </div>
                        }

                        if (decoration.OnClick != null){
                            <button class="interact_button" onclick=@(() => OnClick(decoration)) /> 
                        }
                    }
                }
            </div>
        }
        </div>
    }
</div>

<div>
    <ul>
    @foreach (var debugInfo in map.DebugInfo)
    {
        <li>@debugInfo</li>
    }
    </ul>
</div>

@functions {
    Map map = CreateMap(33, 20);

    [Inject]
    IJSRuntime Runtime { get; set; }

    bool first = true;

    protected override async Task OnAfterRenderAsync()
    {
        // Clunky, and probably has simpler solution, but it works for now. OnAfterRenderAsync is run after each render, and event listeners apparently need to be set here. If first isn't set and checked, we get multiple event listeners registered.
        if(first)
        {
            first = false;
            JsInterop.InteropKeyPress.KeyUp += this.OnKeyUp;
            await this.Runtime.InvokeAsync<bool>("AddOnKeyUpEvent");
        }
    }

    // Create map
    private static Map CreateMap(int width, int height)
    {
        var dg = new DungeonGenerator(width, height);
        dg.Generate();
        dg.Map.RenderGameObjects();
        dg.Map.RenderMoveables();
        return dg.Map;
    }

    private void OnClick(Decoration decoration)
    {
        decoration.OnClick();
        // NOTE: Rerender only gameobject? or rerender every decoration in tile...? Going for the latter, right now...
        //       When I begin to do effecs, I may need to revisit this...
        map.UpdateBlocksLight(decoration.GameObject.x, decoration.GameObject.y, recomputeVisibility: true);
        map.UpdateBlockMovement(decoration.GameObject.x, decoration.GameObject.y);
        map.RenderGameObjects(decoration.GameObject.x, decoration.GameObject.y);
    }

    // TODO: Tried bind to property on player which I change manually; but I can't seem to get it working. Thus, this.StateHasChanged().
    public void OnKeyUp(object sender, ConsoleKey key)
    {
        map.OnKeyPress(key.ToString());
        map.RenderMoveables();
        this.StateHasChanged();
    }
}