@page "/"

@using Microsoft.JSInterop
@inject IJSRuntime JsRuntime;

<!--  PICKUP:
    1. Black spiders are invisible in text - problem. To fix.
    2. Next step, probably more text rendering
    -->

@{
  int gridTileSize = renderAscii ? asciiGridTileSize : graphicGridTileSize; 
  string mapStyle = $"grid-template-rows: repeat({windowHeight}, {gridTileSize}px); grid-template-columns: repeat({windowWidth}, {gridTileSize}px);";
}

<div class="main_window">

    <div id="left_menu" class="left_menu">
        <button type="button" id="mode_switch" class="toggle_button" @onclick=@(() => renderAscii = !renderAscii )>Switch mode</button>
    </div>
    
    <div class="map" style="@mapStyle" id="mapcontainer" @onkeyup="@KeyUp" tabindex="0">
        <!-- map is rendered row by row, top to bottom -->
        @for (int wY = 0; wY < windowHeight; wY++)
        {
            @for (int wX = 0; wX < windowWidth; wX++)
            {
                int x = wX + windowXOffset;
                int y = wY + windowYOffset;

                Tile tile = game.Map.Tiles[x, y];
                string character = tile.Character;
                string charactercolor = tile.CharacterColor;
                string imgFileName = tile.ImageName + ".png";
                string tiletype = tile.TileType.ToString();
                string fovClass = game.Map.IsVisibleMap[x, y] ? "" : "outoffov";
                string tileClass = $"tile {(fovClass)}";
                string cellClass = "cell";

                <div id="@x,@y" class="@cellClass">
                    @if (game.Map.IsMappedMap[x, y])
                    {
                        if (renderAscii)
                        {
                            <div class="@tileClass" style="color:@charactercolor" alt="@x,@y (@tiletype)">@character</div>
                        }
                        else
                        {
                            <div class="@tileClass" style="background-image: url('img/uf_terrain/@imgFileName')" alt="@x,@y (@tiletype)"> </div>
                        }

                        @foreach (var decoration in game.Map.AllDecorations(x, y))
                        {
                            // skip invisibles outside of fov
                            if (decoration.GameObject.InvisibleOutsideFov && !game.Map.IsVisibleMap[x, y])
                            {
                                continue;
                            }

                            bool renderDiv = false;
                            string baseCssClass = "decoration";
                            string animationClass = "";
                            string style = "";
                            string divContent = "";

                            // - handle layer class
                            var layerClass = "decbehind";
                            if (decoration.InFront)
                            {
                                layerClass = "decinfront";
                            }
                            if (renderAscii)
                            {
                                baseCssClass += " decoration-ascii";
                                // weed out those decorations, which shouldn't be shown in ascii
                                if (!String.IsNullOrEmpty(decoration.Character))
                                {
                                    renderDiv = true;
                                    divContent = decoration.Character;
                                    style = $"color:{decoration.CharacterColor ?? "white"}";
                                }
                            }
                            else
                            {
                                // determine css class
                                if (decoration.AnimationClass != null && decoration.AnimationClass != "")
                                {
                                    animationClass = @decoration.AnimationClass;
                                    renderDiv = true;
                                }

                                // determine css style
                                if (decoration.ImageName != null && decoration.ImageName != "")
                                {
                                    string decImgFileName = decoration.ImageName + ".png";

                                    renderDiv = true;
                                    style = $"background-image: url('img/uf_terrain/{decImgFileName}');";
                                }

                                // - handle horizontal and vertical offset
                                string offset = "";
                                if (decoration.Offset != 0)
                                {
                                    offset = $"top: {decoration.Offset}px;";
                                }
                                if (decoration.HOffset != 0)
                                {
                                    offset += $"left: {decoration.HOffset}px;";
                                }

                                style = $"{style}{offset}";
                            }

                            if (renderDiv)
                            {
                                baseCssClass = $"{baseCssClass} {(animationClass)} {(layerClass)} {(fovClass)}";
                                <div class="@baseCssClass" style="@style" alt="@x,@y (Name=@decoration.GameObject.Name, Blocking=@decoration.GameObject.Blocking)">@divContent</div>
                            }

                            if (decoration.OnClick != null)
                            {
                                <button class="interact_button" @onclick=@(() => OnClick(decoration)) />
                            }
                        }
                    }
                </div>
            }
        }
    </div>

    <div id="debuginfo">
        <ul>
            @foreach (var debugInfo in game.Map.DebugInfo)
            {
                <li>@debugInfo</li>
            }
            <li>Player.x: @game.Map.Player.x </li>
            <li>Player.y: @game.Map.Player.y </li>
            <li>windowXOffset: @windowXOffset</li>
            <li>windowYOffset: @windowYOffset</li>
        </ul>
    </div>
</div>

<audio id="bgsound" autoplay loop>
    <source src="sound/Ambience_Cave_00.mp3" type="audio/mpeg">
</audio>

@code {
  bool renderAscii = true;
  const int asciiGridTileSize = 20;
  const int graphicGridTileSize = 48;

  Game game = new Game();

  int windowMoveBufferX = Map.PlayerSightRadius + 1;
  int windowMoveBufferY = Map.PlayerSightRadius + 1;

  int windowWidth = 25;
  int windowHeight = 20;
  int windowXOffset = Int32.MaxValue;
  int windowYOffset = Int32.MaxValue;

  protected override void OnInitialized()
  {
      int optimalXOffset = game.Map.Player.x - windowWidth / 2;
      windowXOffset = optimalXOffset.Clamp(0, game.Map.Width - windowWidth);

      int optimalYOffset = game.Map.Player.y - windowHeight / 2;
      windowYOffset = optimalYOffset.Clamp(0, game.Map.Height - windowHeight);
  }


  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
      if (!firstRender)
      {
          return;
      }

      Game.SoundManager = new SoundManager(JsRuntime);
  }

  public void OnClick(Decoration decoration)
  {
      decoration.OnClick();
      // NOTE: Rerender only gameobject? or rerender every decoration in tile...? Going for the latter, right now...
      //       When I begin to do effecs, I may need to revisit this...
      game.Map.UpdateBlocksLight(decoration.GameObject.x, decoration.GameObject.y, recomputeVisibility: true);
      game.Map.UpdateBlockMovement(decoration.GameObject.x, decoration.GameObject.y);
      game.Map.RenderGameObjects(decoration.GameObject.x, decoration.GameObject.y);
      // TODO Don't I need to Render Moveables here also?
  }

  void KeyUp(KeyboardEventArgs e)
  {
      game.Map.OnKeyPress(e.Code);
      game.Map.RenderMoveables();
      game.Map.PlayerTookTurn();

      // adjust window 
      // NOTE: Assumes step-by-step movement between neighbouring tiles, and optimizes for this (so does not handle, say teleportation)
      if(game.Map.Player.x - windowXOffset < windowMoveBufferX)
      {
          windowXOffset--;
      }

      if(windowXOffset + windowWidth - game.Map.Player.x < windowMoveBufferX)
      {
          windowXOffset++;
      }

      windowXOffset = windowXOffset.Clamp(0, game.Map.Width - windowWidth);

      if(game.Map.Player.y - windowYOffset < windowMoveBufferY)
      {
          windowYOffset--;
      }

      if (windowYOffset + windowHeight - game.Map.Player.y < windowMoveBufferY)
      {
          windowYOffset++;
      }

      windowYOffset = windowYOffset.Clamp(0, game.Map.Height - windowHeight);
  }
}
